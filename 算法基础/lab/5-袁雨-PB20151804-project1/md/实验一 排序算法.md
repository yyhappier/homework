# 实验一 排序算法

*袁雨*  *PB20151804*



## 一、实验内容和要求

#### 1. 实验内容

​		排序n个元素，元素为随机生成的0到$2^{15} − 1$之间的整数，n的取值为： $$2^3, 2^6, 2^9, 2^{12} , 2^{15} , 2^{18}$$。 

​		实现以下算法：堆排序，快速排序， 归并排序，计数排序。

#### 2. 编程要求

​		C/C++，排序算法要自己实现，不能直接调用qsort()等解决。 

#### 3. 目录格式

​		实验需建立根文件夹，文件夹名称为：编号-姓名-学号-project1，在根文件夹下需包括实验报告和ex1子文件夹。实验报告命名为编号-姓名-学号-project1.pdf， ex1子文件夹又包含3个子文件夹： 

​		（1）input文件夹：存放输入数据

​				输入文件中每行一个随机数据，总行数大于等于$2^{15}$ 。 

​				顺序读取n个数据，进行排序。 

​				Example：用快速排序对$2^9$个元素进行排序，其随机数据的输入文件路径为编号-姓名- 学号-project1/ex1/input/input.txt，顺序读取前$2^9$个元素进行排序。 

​		（2）src文件夹：源程序 

​		（3）output文件夹：输出数据

​				每种算法建立一个子文件夹，其输出结果数据导出到其对应子文件下面。 

​				result_n.txt：排序结果的数据(N为数据规模的指数)，每个数据规模一个输出文件。 

​				time.txt：运行时间效率的数据，五个规模的时间结果都写到同一个文件。 

​				Example：用快速排序对29个元素进行排序，其排序结果文件路径为编号-姓名-学号-project1/ex1/output/quick_sort/result_9.txt。



## 二、实验设备和环境

#### 1.	实验设备

​		设备：HUAWEI  MateBook X Pro 

​		处理器：Intel(R) Core(TM) i5-10210U CPU @1.60GHz 2.11 GHz

#### 2.	实验环境

​		vscode, gcc



## 三、实验方法和步骤

​		参考课本堆排序、快速排序、归并排序、计数排序的伪代码，将其中的数组都改为从0开始，并修改相关代码。分别测试完成后，在main.c中引用为头文件。

​		用srand()、rand()等函数生成范围0到RAND_MAX=$2^{15} − 1$的随机数。 

​		用fopen()、  fscanf()、fprintf()、fclose()等函数完成对文件的打开、读写、关闭等操作。

​		用QueryPerformance()等函数完成计时。对输入数据的存取、初始化等均不计入运行时间。

​		用Excel进行数据处理，作出各算法在不同输入规模下的运行时间曲线图，并对结果进行分析讨论。



## 四、实验结果和分析

### （一）实验结果

1. 目录结构

   <img src="C:\Users\袁雨\AppData\Roaming\Typora\typora-user-images\image-20221006232232148.png" alt="image-20221006232232148" style="zoom: 47%;" /><img src="C:\Users\袁雨\AppData\Roaming\Typora\typora-user-images\image-20221006231941557.png" alt="image-20221006231941557" style="zoom: 60%;" />

2. 四个排序算法$n=2^3$时排序结果的截图

   ①堆排序：![image-20221006230537244](C:\Users\袁雨\AppData\Roaming\Typora\typora-user-images\image-20221006230537244.png)

   ②快速排序![image-20221006230632726](C:\Users\袁雨\AppData\Roaming\Typora\typora-user-images\image-20221006230632726.png)

   ③归并排序![image-20221006230601797](C:\Users\袁雨\AppData\Roaming\Typora\typora-user-images\image-20221006230601797.png)

   ④计数排序![image-20221006230421249](C:\Users\袁雨\AppData\Roaming\Typora\typora-user-images\image-20221006230421249.png)

3. 任一排序算法六个输入规模运行时间的截图![image-20221006230659648](C:\Users\袁雨\AppData\Roaming\Typora\typora-user-images\image-20221006230659648.png)



### （二）结果分析

> 四种排序算法在不同规模下运行时间的比较表

| lgn  | heap_sort（s) | quick_sort（s) | merge_sort(s) | counting_sort(s) |
| :--: | :-----------: | :------------: | :-----------: | :--------------: |
|  3   |   0.000001    |    0.000001    |   0.000001    |     0.000226     |
|  6   |   0.000008    |    0.000004    |   0.000007    |     0.000156     |
|  9   |   0.000095    |    0.000048    |   0.000059    |     0.000162     |
|  12  |   0.000998    |    0.000612    |   0.000547    |     0.000186     |
|  15  |   0.009903    |    0.004879    |   0.005570    |     0.000437     |
|  18  |   0.120973    |    0.075114    |   0.079186    |     0.003986     |



![image-20221009002629981](D:\桌面文件\image-20221009002629981.png)

​														

> 课本中的算法渐进性能表

| 算法     | 最坏情况运行时间 | 平均情况／期望运行时间 |
| -------- | ---------------- | ---------------------- |
| 堆排序   | $O(nlgn)$        | ——                     |
| 快速排序 | $\theta(n^2)$    | $\theta(nlgn)$（期望） |
| 归并排序 | $\theta(nlgn)$   | $\theta(nlgn)$         |
| 计数排序 | $\theta(k+n)$    | $\theta(k+n)$          |

​		为了方便比较，对实验数据进行处理。

​		对于堆排序、快速排序和归并排序，计算数据规模lg(nlgn)；将时间的单位转换为微秒，然后计算对数得如下图表。

> 数据处理后的三种算法结果表

|  lg(nlgn)   | heap_sort（$\mu s$) | quick_sort（$\mu s$) | merge_sort($\mu s$) |
| :---------: | :-----------------: | :------------------: | :-----------------: |
| 4.584962501 |          0          |          0           |          0          |
| 8.584962501 |          3          |          2           |     2.807354922     |
| 12.16992500 |     6.569855608     |     5.584962501      |     5.882643049     |
| 15.58496250 |     9.962896005     |     9.257387843      |     9.095397023     |
| 18.90689060 |     13.27364992     |     12.25236977      |     12.44346161     |
| 22.16992500 |     16.88432556     |     16.19679421      |     16.27295777     |

![image-20221009003116553](D:\桌面文件\image-20221009003116553.png)

​			可见堆排序、快速排序、归并排序算法的lg(time)都近似与lg(nlgn)成正比，即运行时间近似与nlgn成正比，符合$\theta(nlgn)$的期望。

​		对于计数排序，计算数据规模lg(k+n)，其中$k=2^{15}-1$；将时间的单位转换为微秒，然后计算对数得如下图表。

> 数据处理后的计数排序结果表

| lg(k+n) | counting_sort($\mu s$) |
| :-----: | :--------------------: |
|  32775  |      7.820178962       |
|  32831  |      7.285402219       |
|  33279  |      7.339850003       |
|  36863  |      7.539158811       |
|  65535  |       8.77148947       |
| 294911  |      11.96072599       |

![image-20221009003316353](D:\桌面文件\image-20221009003316353.png)

​		除了第一次（$2^3$），其他的运行时间都是随数据规模的增长而递增的，因为这几次输入是通过循环依次进行的，故猜测可能是编译器进行了优化等，进行测试，如下图所示。

<img src="D:\桌面文件\image-20221010004833553.png" alt="image-20221010004833553" style="zoom:50%;" />![image-20221010005436378](D:\桌面文件\image-20221010005436378.png)

![image-20221009203323274](D:\桌面文件\image-20221009203323274.png)

​		测试后证实是编译器对C数组的初始化进行了优化，实际的排序时间应近似符合$\theta(k+n)$的期望。

​		综上，各算法在不同输入规模下的运行时间曲线与其渐进性能近似相同。

​		接下来比较不同的排序算法的时间曲线。

​		在规模较小时，比如$$2^3, 2^6, 2^9$$，堆排序、快速排序、归并排序更占优势，其中运行时间近似有快速排序≤归并排序＜堆排序。可能是因为快速排序的代码很紧凑，运行时间中隐含的常数系数很小，故在实际应用中通常较快。

​		在规模较大时，比如$$2^{12} , 2^{15} , 2^{18}$$，$k=O(n)$，计数排序的运行时间与输入数组的规模呈线性关系，更占优势。